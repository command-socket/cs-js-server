{"version":3,"sources":["../ts/command-socket-server.ts"],"names":["ws_1","require","avents_1","node_client_1","CommandSocketServer","[object Object]","port","commandRegistry","this","connectionMap","Map","internalServer","Server","events","CommandSocketServerEvents","on","websocket","__awaiter","connection","CommandSocket","create","set","getID","getEvents","CONNECTION_OPENED","notify","CLOSE","subscribe","event","delete","source","id","has","get","callback","values","forEachConnection","close","exports","AventNotifier","CONNECTION_CLOSED"],"mappings":"4YAMA,MAAAA,KAAAC,QAAA,MACAC,SAAAD,QAAA,UAKAE,cAAAF,QAAA,+BASA,MAAaG,oBAuBZC,YAAmBC,EAAcC,GAEhCC,KAAKC,cAAgB,IAAIC,IAEzBF,KAAKG,eAAiB,IAAIX,KAAAY,OAAgB,CAAEN,KAAAA,IAE5CE,KAAKK,OAAS,IAAIC,0BAElBN,KAAKG,eAAeI,GAAG,aAAqBC,GAAuCC,UAAAT,UAAA,OAAA,GAAA,YAElF,IAAIU,QAA+Cf,cAAAgB,cAAcC,OAAOJ,EAAWT,GAEnFC,KAAKC,cAAcY,IAAIH,EAAWI,QAASJ,GAG3CV,KAAKe,YAAYC,kBAAkBC,OAAOP,GAE1CA,EAAWK,YAAYG,MAAMC,UAAWC,IAEvCpB,KAAKC,cAAcoB,OAAOD,EAAME,OAAOR,eAcnCjB,mBAAmB0B,GAEzB,OAAOvB,KAAKC,cAAcuB,IAAID,GAKxB1B,mBAAmB0B,GAEzB,OAAOvB,KAAKC,cAAcwB,IAAIF,GAKxB1B,sBAQAA,kBAAkB6B,GAExB,IAAK,IAAIhB,KAAcV,KAAKC,cAAc0B,SAAUD,EAAShB,GASvDb,YAEN,OAAOG,KAAKK,OAONR,QAENG,KAAK4B,kBAAmBlB,GAAgDA,EAAWmB,SACnF7B,KAAKG,eAAe0B,SArGtBC,QAAAlC,oBAAAA,oBAmHA,MAAaU,0BASZT,cAECG,KAAKgB,kBAAoB,IAAItB,SAAAqC,cAC7B/B,KAAKgC,kBAAoB,IAAItC,SAAAqC,eAZ/BD,QAAAxB,0BAAAA","file":"command-socket-server.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t7:55 PM -- September 18th, 2019.\n *\tProject: @command-socket/server\n */\n\nimport WebSocket, { Server as WebSocketServer } from \"ws\";\nimport { AventNotifier } from \"avents\";\nimport {\n\tCommandRegistry,\n\tCommandSetStructure\n} from \"@command-socket/core\";\nimport { CommandSocket } from \"@command-socket/node-client\";\n\n/**\n * A server that is responsible for maintaining many concurrent connections to various clients.\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n */\nexport class CommandSocketServer<\n\tLCS extends CommandSetStructure = any,\n\tRCS extends CommandSetStructure = any,\n\tM extends {} = {}> {\n\t\n\t/**\n\t * A mapping from CommandSocket IDs to CommandSockets, including all currently connected clients.\n\t */\n\tprivate connectionMap: Map<string, CommandSocket<LCS, RCS, M>>;\n\t\n\t// DOC-ME [1/13/20 @ 12:14 PM] - Documentation required!\n\tprivate internalServer: WebSocketServer;\n\t\n\t// DOC-ME [1/13/20 @ 12:14 PM] - Documentation required!\n\tprivate readonly events: CommandSocketServerEvents;\n\t\n\t/**\n\t * Initializes a new CommandSocketServer with a a specified port and, optionally, a CommandRegistry to use for each\n\t * spawned serverside CommandSocket.\n\t *\n\t * @param port The port on which to start the CommandSocketServer.\n\t * @param commandRegistry The CommandRegistry to use for each spawned serverside CommandSocket.\n\t */\n\tpublic constructor(port: number, commandRegistry?: CommandRegistry<LCS>) {\n\t\n\t\tthis.connectionMap = new Map<string, CommandSocket<LCS, RCS, M>>();\n\t\t\n\t\tthis.internalServer = new WebSocketServer({ port });\n\t\t\n\t\tthis.events = new CommandSocketServerEvents();\n\t\t\n\t\tthis.internalServer.on(\"connection\", async (websocket: WebSocket): Promise<void> => {\n\t\t\t\n\t\t\tlet connection: CommandSocket<LCS, RCS, M> = await CommandSocket.create(websocket, commandRegistry);\n\t\t\t\n\t\t\tthis.connectionMap.set(connection.getID(), connection);\n\t\t\t\n\t\t\t// FIX-ME [11/26/19 @ 1:58 AM] - This is not the correct way to fix the below issue...\n\t\t\tthis.getEvents().CONNECTION_OPENED.notify(connection as unknown as CommandSocket);\n\t\t\t\n\t\t\tconnection.getEvents().CLOSE.subscribe((event: { source: CommandSocket }): void => {\n\t\t\t\t\n\t\t\t\tthis.connectionMap.delete(event.source.getID());\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t});\n\t\n\t}\n\t\n\t/**\n\t * Returns true if the instance has a connection to a client CommandSocket with the specified ID.\n\t *\n\t * @param id The ID to check for an associated connected client.\n\t * @return true if the instance has a connection to a client CommandSocket with the specified ID.\n\t */\n\tpublic hasConnectionForID(id: string): boolean {\n\t\t\n\t\treturn this.connectionMap.has(id);\n\t\t\n\t}\n\t\n\t// DOC-ME [1/13/20 @ 12:14 PM] - Documentation required!\n\tpublic getConnectionForID(id: string): CommandSocket<LCS, RCS, M> | undefined {\n\t\t\n\t\treturn this.connectionMap.get(id);\n\t\t\n\t}\n\t\n\t// DOC-ME [1/13/20 @ 12:14 PM] - Documentation required!\n\tpublic getCommandRegistry(): any {\n\t\n\t\t// TODO [10/19/19 @ 5:26 PM] - Finish the 'getCommandRegistry' method.\n\t\treturn undefined;\n\t\n\t}\n\t\n\t// DOC-ME [1/13/20 @ 12:14 PM] - Documentation required!\n\tpublic forEachConnection(callback: (connection: CommandSocket<LCS, RCS, M>) => any): void {\n\t\t\n\t\tfor (let connection of this.connectionMap.values()) callback(connection);\n\t\t\n\t}\n\t\n\t/**\n\t * Returns a collection of events relevant to this CommandSocketServer instance.\n\t *\n\t * @return A collection of events relevant to this CommandSocketServer instance.\n\t */\n\tpublic getEvents(): CommandSocketServerEvents {\n\t\t\n\t\treturn this.events;\n\t\t\n\t}\n\t\n\t/**\n\t * Properly closes the server, including all of it's associated connections to client CommandSockets.\n\t */\n\tpublic close(): void {\n\t\t\n\t\tthis.forEachConnection((connection: CommandSocket<LCS, RCS, M>): any => connection.close());\n\t\tthis.internalServer.close();\n\t\t\n\t}\n\t\n}\n\n/**\n * An enumeration of events relevant to any given CommandSocketServer instance.\n *\n * @author Trevor Sears <trevorsears.main@gmail.com>\n * @version v0.1.0\n * @since v0.1.0\n * @see CommandSocketServer#getEvents\n */\nexport class CommandSocketServerEvents {\n\t\n\t// DOC-ME [1/13/20 @ 12:16 PM] - Documentation required!\n\tpublic readonly CONNECTION_OPENED: AventNotifier<CommandSocket>;\n\t\n\t// DOC-ME [1/13/20 @ 12:16 PM] - Documentation required!\n\tpublic readonly CONNECTION_CLOSED: AventNotifier<void>;\n\t\n\t// DOC-ME [1/13/20 @ 12:16 PM] - Documentation required!\n\tpublic constructor() {\n\t\t\n\t\tthis.CONNECTION_OPENED = new AventNotifier<CommandSocket>();\n\t\tthis.CONNECTION_CLOSED = new AventNotifier<void>();\n\t\t\n\t}\n\t\n}"]}